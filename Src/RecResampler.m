//
//  Redesigned WarpTab
//

#import "RecResampler.h"
#import "RecImage.h"
#import "RecLoop.h"
#import "RecLoopControl.h"
#import "RecUtil.h"

#import "RecResampler.cl.h"   // generated by Xcode

#import <sys/time.h>
#import "timer_macros.h"

// Lanczos kernel + DC correction -> write tech note (appendix for rtf3)
// returns table of length len+1
float *
Rec_lanczos_kern(int len, int order)
{
    float   *kern;
    float   *dc_err;
    float   w, x;
    int     i, k, n;
    BOOL    dc_corr = YES;

// Lanczos kernel
	kern = (float *)malloc(sizeof(float) * (len + 1));
	for (i = 0; i <= len; i++) {
		if (i == 0) {
			kern[i] = 1.0;
		} else {
			x = (float)i * order * M_PI / len;
			w = (sin(x) / x) * (sin(x/order) / (x/order));
			kern[i] = w;
		}
	}

// DC correction
    if (dc_corr) {
        n = (int)len / order;
        dc_err = (float *)malloc(sizeof(float) * (n + 1));
        for (i = 0; i <= n; i++) {
            dc_err[i] = 0;
        }
    // pos side
        for (k = 0; k < order; k++) {
            for (i = 0; i <= n; i++) {
                w = kern[k * n + i];
                dc_err[i] += w;
            }
        }
    // neg side
        for (k = 0; k < order; k++) {
            for (i = 0; i <= n; i++) {
                w = kern[k * n + n - i];
                dc_err[i] += w;
            }
        }
    // error component
        for (i = 0; i <= n; i++) {
            dc_err[i] -= 1.0;
        //    printf("%d %f\n", i, dc_err[i]);
        }
    // kernel correction
        for (k = 0; k < order; k++) {
            for (i = 1; i < n; i++) {
                kern[k * n + i] -= dc_err[i] / (order * 2);
            }
        }
        free(dc_err);
    }
    return kern;
}

float *
Rec_said_kern(int len, int order, float chi, float eta)
{
    float   *p;
    int     i;
    float   x, snc, csh, gs, w;

    p = (float *)malloc(sizeof(float) * (len + 1));
    for (i = 0; i < len; i++) {
        if (i == 0) {
            p[i] = w = 1.0;
            snc = csh = gs = 1.0;
        } else {
			x = (float)i * order * M_PI / len;
            snc = sin(x) / x;
            csh = cosh(sqrt(2 * eta) * chi * x / (2 - eta));
            w = chi * x / (2.0 - eta);
            gs = exp(-w*w);
            w = snc * csh * gs;
            p[i] = w;
        }
        printf("%d %f %f %f %f %f\n", i, snc, csh, gs, csh * gs, w);
    }

    return p;
}

// same as 2D version (... 2D uses 1D table)
// 1-sided table... truncation direction is significant
int
warp_kernel_index(float dist, int step, int len)
{
	int		ix;

    ix = floor(dist * step);    // two-sided
    ix = abs(ix);

	if (ix < 0) ix = 0;
	if (ix > len)  ix = len;

	return ix;
}

// ==== 2-D ======
@implementation	RecResampler

+ (id)resamplerWithSrc:(RecImage *)src dst:(RecImage *)dst map:(RecImage *)map
{
    return [[RecResampler alloc] initWithSrc:src dst:dst map:(RecImage *)map];
}

// 512 slice resampling
// 0:time: 4.534668 (sec) CPU 
// 1:time: 1.069392 (sec) OP 
// 2:time: 1.160008 (sec) GPU global (kernel = 0.760099)
// 3:time: 1.236769 (sec) GPU local

// complex not supported yet (can be done on host side)
- (id)initWithSrc:(RecImage *)srcImg dst:(RecImage *)dstImg map:(RecImage *)mapImg
{
    self = [super init];
    if (!self) return nil;

    mode = 1;   // 0:ref 1:op 2:cl, 3:cl2 default is OP
    src = srcImg;
    dst = dstImg;
    map = mapImg;
    [self setLoopControls];

    return self;
}

- (void)setMode:(int)warp_mode
{
    mode = warp_mode;
}


- (void)createWarpTab
{
	int             kern_len = KERN_LEN; //300;                     // length of kernel LUT tab
	int             kern_step = kern_len / LANCZ_ORDER; // step size corresponding to 1.0 interval
	float           *kernel;
	float			*mapX, *mapY;
	int				i, j, k, kern_ix;
	int				ix;
	int				dim;
	float			x, y, wx, wy, w, dist;
	int				xi, yi, xpos, ypos;
	int				xdim, ydim;
	int				srcXdim, srcYdim;

// dst dim (== map dim)
	xdim = [dst xDim];
	ydim = [dst yDim];

	srcXdim = [src xDim];
	srcYdim = [src yDim];

// make kernel (one-sided)
    kernel = Rec_lanczos_kern(kern_len, LANCZ_ORDER);

// init warp tab
	warp_tab_len = xdim * ydim;	// dst dim
	dim = LANCZ_ORDER * 2;
	mapX = [map currentDataWithControl:mapLc];
	mapY = mapX + [map dataLength];
	kern_size = dim * dim;
	warp_tab = (RecWarpTab *)malloc(sizeof(RecWarpTab) * warp_tab_len);

    ix = 0;
    // dim = 6, ix = 0..35
    for (i = 0; i < dim; i++) {
        for (j = 0; j < dim; j++, ix++) {
            posOffset[ix] = i * srcXdim + j;
        }
    }
    // tab_len = dst_xdim * dst_ydim
    for (k = 0; k < warp_tab_len; k++) {
        x = mapX[k] * srcXdim + srcXdim/2;
        xi = (int)ceil(x) - LANCZ_ORDER;
        x = xi - x;
        y = mapY[k] * srcYdim + srcYdim/2;
        yi = (int)ceil(y) - LANCZ_ORDER;
        y = yi - y;
        warp_tab[k].cornerIx = yi * srcXdim + xi;
        for (i = 0; i < dim; i++) {
            ypos = yi + i;
            if (ypos < 0 || ypos >= srcYdim) {
                wy = 0;
            } else {
                dist = y + i;
                kern_ix = warp_kernel_index(dist, kern_step, kern_len);
                wy = kernel[kern_ix];
                if (wy != wy) {
                    printf("=== 2D, wy = NaN, kern[%d] = %f\n", kern_ix, wy);
                }
            }
            for (j = 0; j < dim; j++) {
                xpos = xi + j;
                if (xpos < 0 || xpos >= srcXdim) {
                    wx = 0;
                } else {
                    dist = x + j;
                    kern_ix = warp_kernel_index(dist, kern_step, kern_len);
                    wx = kernel[kern_ix];
                    if (wx != wx) {
                        printf("=== 2D, wy = NaN, kern[%d] = %f\n", kern_ix, wx);
                    }
                }
                w = wx * wy;
                warp_tab[k].wt[i * dim + j] = w;
            }
        }
    }
    free(kernel);

// chk
//    [self chkWarpTab];
}

- (void)freeWarpTab
{
	if (warp_tab) {
		free(warp_tab);
		warp_tab = NULL;
	}
	warp_tab_len = 0;
}

// create warp tab and resample
- (void)resample
{
    [dst clear];
    switch (mode) {
    case REC_REF: // ref
        [self resample_ref];
        break;
    case REC_OP: // op
        [self resample_op];
        break;
    case REC_CL: // GPU
    printf("CL mode\n");
        [self resample_cl_1];
        break;
    case REC_CL2: // GPU 2
    printf("CL2 mode\n");
        [self resample_cl_2];
        break;
    }
}

// kernel only version ... works ok now
// complex not supported yet (can be done on host side)
- (void)resample_cl_2
{
// resample
    int                 i, n = [mapLc loopLength];
    int                 j, m = [dstLc loopLength];
    int                 six, dix;
// OpenCL
    int                 dev = 0;    // 0: GPU, 1: GPU, 2: CPU
    size_t              length, src_len, dst_len, map_len;
    cl_context          context;
    cl_device_id        devices[8];
    char                name[128];
    dispatch_queue_t    queue;
    void                *cl_src, *cl_dst, *cl_map_x, *cl_map_y;  // CL memory objects
    float               *kern;

//TIMER_ST

    context = gcl_get_context();    // get context
    clGetContextInfo(context, CL_CONTEXT_DEVICES, sizeof(devices), devices, &length);   // get devices
    queue = gcl_create_dispatch_queue(CL_DEVICE_TYPE_GPU, devices[dev]);
//    queue = gcl_create_dispatch_queue(CL_DEVICE_TYPE_GPU, NULL);    // create queue
    if (queue == NULL) {
        printf("GPU not found. Using CPU.\n");
        queue = gcl_create_dispatch_queue(CL_DEVICE_TYPE_CPU, NULL);
    }

    clGetDeviceInfo(gcl_get_device_id_with_dispatch_queue(queue), CL_DEVICE_NAME, 128, name, NULL);
    printf("%s\n", name);

// make kernel
    kern = Rec_lanczos_kern(KERN_LEN, LANCZ_ORDER);

// cl memory objects
    src_len = [src xDim] * [src yDim] * [src zDim];
    dst_len = [dst xDim] * [dst yDim] * [dst zDim];
    map_len = [map xDim] * [map yDim];

    cl_src   = gcl_malloc(sizeof(cl_float) * src_len,  [src data], CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR);
    cl_map_x = gcl_malloc(sizeof(cl_float) * map_len,  [map data], CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR);
    cl_map_y = gcl_malloc(sizeof(cl_float) * map_len,  [map data] + [map dataLength], CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR);
    cl_dst   = gcl_malloc(sizeof(cl_float) * dst_len,  NULL, CL_MEM_WRITE_ONLY);

//TIMER_END("CL prep ")		//  time: 0.768174 (sec) resample 

    [mapLc rewind];
    for (i = 0; i < n; i++) {
        // resample
        [dstLc rewind];
        for (j = 0; j < m; j++) {
            six = [srcLc current];
            dix = [dstLc current];
            dispatch_sync(queue, ^{
                cl_ndrange range = {2, {0, 0, 0}, {[dst xDim], [dst yDim], 0}, {16, 16, 0}};
                resample2_kernel(&range, (cl_float *)cl_src, six, (cl_float *)cl_dst, dix,
                     (cl_float *)cl_map_x, (cl_float *)cl_map_y, [src xDim], [dst xDim]);
            });
            [dstLc increment];
        }
        [mapLc increment];
    }
//TIMER_END("CL kernel ")		//  time: 0.768174 (sec) resample 
    dispatch_sync(queue, ^{
        gcl_memcpy([dst data], cl_dst, sizeof(cl_float) * dst_len);
    });

    // free mem objects
    gcl_free(cl_src);
    gcl_free(cl_dst);
    gcl_free(cl_map_x);
    gcl_free(cl_map_y);
    // release queue
    dispatch_release(queue);
}

// global only version (transfer warp tab) ... works ok
//  time: 0.417632 (sec) with overhead only (no kernel code)
- (void)resample_cl_1
{
// resample
    int                 i, n = [mapLc loopLength];
    int                 j, m = [dstLc loopLength];
    int                 six, dix;
// OpenCL
    int                 dev = 0;    // 0: GPU, 1: GPU, 2: CPU, CPU doens't work
    size_t              length, src_len, dst_len;
    cl_context          context;
    cl_device_id        devices[8];
    char                name[128];
    dispatch_queue_t    queue;
    void                *cl_src, *cl_dst, *cl_tab;  // CL memory objects

//TIMER_ST

    context = gcl_get_context();    // get context
    clGetContextInfo(context, CL_CONTEXT_DEVICES, sizeof(devices), devices, &length);   // get devices
    queue = gcl_create_dispatch_queue(CL_DEVICE_TYPE_GPU, devices[dev]);

    clGetDeviceInfo(gcl_get_device_id_with_dispatch_queue(queue), CL_DEVICE_NAME, 128, name, NULL);
    printf("%s\n", name);

// cl memory objects
    src_len = [src xDim] * [src yDim] * [src zDim];
    dst_len = [dst xDim] * [dst yDim] * [dst zDim];

    cl_src = gcl_malloc(sizeof(cl_float) * src_len, [src data], CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR);
    cl_dst = gcl_malloc(sizeof(cl_float) * dst_len, NULL, CL_MEM_WRITE_ONLY);

//TIMER_END("CL prep ")		//  time: 0.768174 (sec) resample 

    [mapLc rewind];
    for (i = 0; i < n; i++) {
        [self createWarpTab];
        cl_tab = gcl_malloc(sizeof(RecWarpTab) * warp_tab_len, warp_tab, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
        // resample
        [dstLc rewind];
        for (j = 0; j < m; j++) {
            six = [srcLc current];
            dix = [dstLc current];
            dispatch_sync(queue, ^{
                cl_ndrange range = {2, {0, 0, 0}, {[dst xDim], [dst yDim], 0}, {16, 16, 0}};
                resample1_kernel(&range, (cl_float *)cl_src, six, (cl_float *)cl_dst, dix, (WarpTab *)cl_tab, [src xDim], [dst xDim]);
            });
            [dstLc increment];
        }
        [self freeWarpTab];
        [mapLc increment];
        gcl_free(cl_tab);
    }
    dispatch_sync(queue, ^{
        gcl_memcpy([dst data], cl_dst, sizeof(cl_float) * dst_len);
    });

//TIMER_END("CL kernel ")		//  time: 0.768174 (sec) resample 

    // free mem objects
    gcl_free(cl_src);
    gcl_free(cl_dst);
    // release queue
    dispatch_release(queue);
}

- (void)resample_op
{
    int                 i, n = [mapLc loopLength];
    int                 j, m = [dstLc loopLength];
    float               *sp, *dp;
	NSOperation			*op;
	NSOperationQueue	*queue = [[NSOperationQueue alloc] init];;

    [mapLc rewind];
    for (i = 0; i < n; i++) {
        [self createWarpTab];
        // resample
        [dstLc rewind];
        for (j = 0; j < m; j++) {
            sp = [src currentDataWithControl:srcLc];
            dp = [dst currentDataWithControl:dstLc];
           // [self resampleSrc:sp dst:dp];
            op = [RecResamplerOp opWithResampler:self src:sp dst:dp];
            [queue addOperation:op];
            [dstLc increment];
        }
        [queue waitUntilAllOperationsAreFinished];
        [self freeWarpTab];
        [mapLc increment];
    }
}

- (void)resample_ref
{
    int     i, n = [mapLc loopLength];
    int     j, m = [dstLc loopLength];
    float   *sp, *dp;

    [mapLc rewind];
    for (i = 0; i < n; i++) {
        [self createWarpTab];
        // resample
        [dstLc rewind];
        for (j = 0; j < m; j++) {
            sp = [src currentDataWithControl:srcLc];
            dp = [dst currentDataWithControl:dstLc];
            [self resampleSrc:sp dst:dp];
            [dstLc increment];
        }
        [self freeWarpTab];
        [mapLc increment];
    }
}

// resample single xy plane
- (void)resampleSrc:(float *)sp dst:(float *)dp
{
    float       *p;
    RecWarpTab  *tab;
    float       sum;
    int         plane, pixSize = [dst pixSize];
    int         i, j;

    for (plane = 0; plane < pixSize; plane++) {
        for (i = 0; i < warp_tab_len; i++) {
            tab = &(warp_tab[i]);
            p = sp + tab->cornerIx;
            sum = 0;

            for (j = 0; j < kern_size; j++) {	// kern_size = 36
                if (tab->wt[j] != 0) {
                    sum += p[posOffset[j]] * tab->wt[j];
                }
            }
            dp[i] = sum;
        }
        sp += [src dataLength];
        dp += [dst dataLength];
    }
}

- (void)setLoopControls
{
    RecLoopControl  *control;       // contains all loops (states)
    NSMutableArray  *loops = [NSMutableArray array];
    RecLoop         *lp;
    int             i, n;

// contains all loops
    // dst
    n = [dst dim];
    for (i = 0; i < n; i++) {
        lp = [dst loopAtIndex:i];
        if (![loops containsObject:lp]) {
            [loops addObject:lp];
        }
    }
    // src
    n = [src dim];
    for (i = 0; i < n; i++) {
        [loops addObject:[src loopAtIndex:i]];
    }
    // map
    n = [map dim];
    for (i = 0; i < n; i++) {
        lp = [dst loopAtIndex:i];
        if (![loops containsObject:lp]) {
            [loops addObject:lp];
        }
    }
    // make loopControl (loop order doesn't matter)
    control = [RecLoopControl controlWithLoopArray:loops];      // [ch, sl, pe, y, x]

    // map (map loop counter)
    mapLc = [RecLoopControl controlWithControl:control forImage:map];   // [pe, y-, x-]
    [mapLc deactivateXY];

    // dst outer (dst loop counter)
    dstLc = [RecLoopControl controlWithControl:control forImage:dst];    // [ch, sl, pe-, y-, x-]
    [dstLc deactivateXY];
    [dstLc deactivateLoopsContainedIn:mapLc];

    // src (passive)
    srcLc = [RecLoopControl controlWithControl:control forImage:src];
}

// debug (2D)
- (void)chkWarpTab
{
    int     i, k, ix;
    int     x, y;
    int     xDim = [src xDim];
    int     yDim = [src yDim];
    float   w;

//    printf("chkWarpTab:2D\n");
    for (k = 0; k < warp_tab_len; k++) {
        for (i = 0; i < kern_size; i++) {
            ix = warp_tab[k].cornerIx + i;
            x = ix % xDim;
            y = ix / xDim;
            w = warp_tab[k].wt[i];
            if (w > -1.0 && ((x < 0) || (x >= xDim) || (y < 0) || (y >= yDim))) {
                printf("# warptab 2D ix error: k/x/y = %d (%d/%d) %e\n", k, x, y, w);
            }
            if ((w > 1.0) || (w != w)) {
                printf("# warptab 2D weight error:tab[%d].wt[%d] = %e\n", k, i, w);
            }
        }
    }
}


@end

// ==== 1-D ======
@implementation	RecResampler1d

+ (id)resamplerWithSrc:(RecImage *)src dst:(RecImage *)dst loopAt:(int)ix map:(RecImage *)map
{
    return [[RecResampler1d alloc] initWithSrc:src dst:dst loopAt:ix map:map];
}

- (id)initWithSrc:(RecImage *)srcImg dst:(RecImage *)dstImg loopAt:(int)ix map:(RecImage *)mapImg
{
    self = [super init];
    if (!self) return nil;

    mode = 1;   // 0:cpu, 1:op, 2:CL global, 3:CL local
    loop_index = ix;
    src = srcImg;
    dst = dstImg;
    map = mapImg;
    [self setLoopControls];
    [self createWarpTab];

    return self;
}

- (void)dealloc
{
    [self freeWarpTab];
}

- (void)createWarpTab
{
	int             kern_step;      // step size corresponding to 1.0 interval
	int             kern_len;       // length of kernel LUT tab
	float           *kernel;
	float			*map_p;
	int				i, k, kern_ix;
	int				dim;
    int             srcDim, dstDim;
	float			x, w, dist;
	int				xi;

	dstDim = [map xDim];
    srcDim = [[srcLc loopAtIndex:loop_index] dataLength];

// make kernel (one-sided)
    kern_len = KERN_LEN; //300;
	kern_step = kern_len / LANCZ_ORDER;

// actual length = kern_len + 1 (including 0 and kern_len)
    kernel = Rec_lanczos_kern(kern_len, LANCZ_ORDER);
//    kernel = Rec_said_kern(kern_len, LANCZ_ORDER, 0.284, 0.65);

// init warp tab
	warp_tab_len = dstDim;
	dim = LANCZ_ORDER * 2;
    map_p = [map data];
	kern_size = dim;
	warp_tab = (RecWarpTab1d *)malloc(sizeof(RecWarpTab1d) * warp_tab_len);

    // tab_len == dst_looplen
    for (k = 0; k < warp_tab_len; k++) {
		// below line is sensitive to position in src ####
        x = map_p[k] * dstDim + (float)(srcDim-1)/2; // [-0.5..0.5] -> [0..srcDim-1] (float) (+ overrange covering dstdim)
        xi = (int)ceil(x) - LANCZ_ORDER ;  // index of 1st point, relative to src origin (could be negative)
        x = xi - x; // float position within kernel (negative)
        warp_tab[k].leftIx = xi;    // src ix of leftmost point
        for (i = 0; i < dim; i++) {
            if (xi + i < 0 || xi + i >= srcDim) {
                w = 0;
            } else {
                dist = x + i;     // float dist from origin of kernel
                kern_ix = warp_kernel_index(dist, kern_step, kern_len);  // index into kernel tab
                w = kernel[kern_ix];    // weight value [0..1.0]
            }
            warp_tab[k].wt[i] = w;
        //    if (w != w) printf("NaN at creation time (1D), %d\n", xi);
        }
    }
    free(kernel);

// chk
//    [self chkWarpTab];
}

- (void)freeWarpTab
{
	if (warp_tab) {
		free(warp_tab);
		warp_tab = NULL;
	}
}

// create warp tab and resample
- (void)resample
{
    [dst clear];
    switch (mode) {
    case 0: // ref
        [self resample_ref];
        break;
    case 1: // op
        [self resample_op];
        break;
    case 2: // GPU
        [self resample_cl];
        break;
    }
//    if ([dst checkNaN]) {
//        printf("RecResampler1D: NaN found\n");
//    }
}

- (void)resample_cl
{
    [self resample_cl_1];     // warp_tab base
//    [self resample_cl_2];       // kernel only
}

// works ok
// 1D parallel : time: 3.130462 (sec) z scale
// 2D parallel : time: 0.839956 (sec) z scale 

// do loop calc on host side
// 1D, global only, tab based
- (void)resample_cl_1   // 1-D
{
// resample
    int                 j, m;
    int                 six, dix;
    int                 xDim, srcSkip, dstSkip;
// OpenCL
    int                 dev = 0;    // 0: GPU, 1: GPU, 2: CPU
    size_t              length, src_len, dst_len;
    cl_context          context;
    cl_device_id        devices[8];
    char                name[128];
    dispatch_queue_t    queue;
    void                *cl_src, *cl_dst, *cl_tab;  // CL memory objects

//TIMER_ST

    context = gcl_get_context();    // get context
    clGetContextInfo(context, CL_CONTEXT_DEVICES, sizeof(devices), devices, &length);   // get devices
    queue = gcl_create_dispatch_queue(CL_DEVICE_TYPE_GPU, devices[dev]);
//    queue = gcl_create_dispatch_queue(CL_DEVICE_TYPE_GPU, NULL);    // create queue
    if (queue == NULL) {
        printf("GPU not found. Using CPU.\n");
        queue = gcl_create_dispatch_queue(CL_DEVICE_TYPE_CPU, NULL);
    }

    clGetDeviceInfo(gcl_get_device_id_with_dispatch_queue(queue), CL_DEVICE_NAME, 128, name, NULL);
    printf("%s\n", name);

// cl memory objects (entire image)
    src_len = [src dataLength];
    dst_len = [dst dataLength];

    cl_src = gcl_malloc(sizeof(cl_float) * src_len, [src data], CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR);
    cl_dst = gcl_malloc(sizeof(cl_float) * dst_len, NULL, CL_MEM_WRITE_ONLY);
    cl_tab = gcl_malloc(sizeof(RecWarpTab1d) * warp_tab_len, warp_tab, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);

//TIMER_END("CL prep (1D)")		//  time: 0.768174 (sec) resample 
    if (loop_index == ([src dim] - 1)) {    // lp == x, 2nd = y
        xDim = [dst yDim];
        srcSkip = [src skipSizeForLoop:[src yLoop]];
        dstSkip = [dst skipSizeForLoop:[dst yLoop]];
        [srcLc deactivateY];
        [dstLc deactivateY];
        printf("lp = x, 2nd = y, s/d skip = %d/%d\n", srcSkip, dstSkip);
    } else {                                // lp = ?, 2nd = x
        xDim = [dst xDim];
        srcSkip = [src skipSizeForLoop:[src xLoop]];
        dstSkip = [dst skipSizeForLoop:[dst xLoop]];
        [srcLc deactivateX];
        [dstLc deactivateX];
        printf("lp = z, 2nd = x, s/d skip = %d/%d\n", srcSkip, dstSkip);
    }

    m = [dstLc loopLength];
printf("loopLen = %d\n", m);
    [dstLc rewind];
    for (j = 0; j < m; j++) {
        six = [srcLc current];
        dix = [dstLc current];
        dispatch_sync(queue, ^{
        //    cl_ndrange range = {1, {0, 0, 0}, {warp_tab_len, 0, 0}, {256, 0, 0}};
            cl_ndrange range = {2, {0, 0, 0}, {warp_tab_len, xDim, 0}, {256, 1, 0}};
            resample1d_kernel(&range, (cl_float *)cl_src, six, (cl_float *)cl_dst, dix, skip, srcSkip, dstSkip, xDim, (WarpTab1d *)cl_tab);
        });
        [dstLc increment];
    }

    dispatch_sync(queue, ^{
        gcl_memcpy([dst data], cl_dst, sizeof(cl_float) * dst_len);
    });
//TIMER_END("CL kernel (1D)")		//  time: 0.768174 (sec) resample 

    // free mem objects
    gcl_free(cl_tab);
    gcl_free(cl_src);
    gcl_free(cl_dst);
    // release queue
    dispatch_release(queue);

    [self freeWarpTab];
}

// kernel only
- (void)resample_cl_2
{
}

- (void)resample_op
{
    int                 j, m = [dstLc loopLength];
    float               *sp, *dp;
	NSOperation			*op;
	NSOperationQueue	*queue = [[NSOperationQueue alloc] init];;

//    [self createWarpTab];
    // resample
    [dstLc rewind];
    for (j = 0; j < m; j++) {   // dst loop
        sp = [src currentDataWithControl:srcLc];
        dp = [dst currentDataWithControl:dstLc];
       // [self resampleSrc:sp dst:dp];
        op = [RecResampler1dOp opWithResampler:self src:sp dst:dp];
        [queue addOperation:op];
        [dstLc increment];
    }
    [queue waitUntilAllOperationsAreFinished];
//    [self freeWarpTab];
}

- (void)resample_ref
{
    int     j, m = [dstLc loopLength];
    float   *sp, *dp;

    // resample
    [dstLc rewind];
    for (j = 0; j < m; j++) {
        sp = [src currentDataWithControl:srcLc];
        dp = [dst currentDataWithControl:dstLc];
        [self resampleSrc:sp dst:dp];
        [dstLc increment];
    }
}

- (void)resampleSrc:(float *)sp dst:(float *)dp
{
    float           *p;
    RecWarpTab1d    *tab;
    float           sum;
    int             plane, pixSize = [dst pixSize];
    int             i, j, ix;

    for (plane = 0; plane < pixSize; plane++) {
        for (i = 0; i < warp_tab_len; i++) {
            tab = &(warp_tab[i]);
            p = sp + tab->leftIx * skip;
            sum = 0;

            for (j = ix = 0; j < kern_size; j++, ix += skip) {	// kern_size = 6
                if (tab->wt[j] != 0) {
                    sum += p[ix] * tab->wt[j];
                }
            }
            dp[i * skip] = sum;
        }
        sp += [src dataLength];
        dp += [dst dataLength];
    }
}

- (void)setLoopControls
{
    RecLoopControl  *control;
    NSMutableArray  *loops = [NSMutableArray array];
    RecLoop         *lp, *targetLp;
    int             i, n;

// contains all loops
    // src
    n = [src dim];
    for (i = 0; i < n; i++) {
        [loops addObject:[src loopAtIndex:i]];
    }
    // dst
    n = [dst dim];
    for (i = 0; i < n; i++) {
        lp = [dst loopAtIndex:i];
        if (![loops containsObject:lp]) {
            [loops addObject:lp];
        }
    }
    // map
    n = [map dim];
    for (i = 0; i < n; i++) {
        lp = [dst loopAtIndex:i];
        if (![loops containsObject:lp]) {
            [loops addObject:lp];
        }
    }
    // make loopControl (loop order doesn't matter)
    control = [RecLoopControl controlWithLoopArray:loops];      // [ch, sl, pe, y, x]

    // dst outer (dst loop counter)
    dstLc = [RecLoopControl controlWithControl:control forImage:dst];    // [ch, sl, pe-, y-, x-]
//    zLp = [dst zLoop];
    targetLp = [dst loopAtIndex:loop_index];
    [dstLc deactivateLoop:targetLp];

    // src (passive)
    srcLc = [RecLoopControl controlWithControl:control forImage:src];
    skip = [src skipSizeForLoop:[src loopAtIndex:loop_index]];
}

// debug (1D)
- (void)dumpWarpTab
{
    int     i, k;
    float   w;

    for (i = 0; i < 6; i++) {
        printf("%d ", i);
        for (k = 10; k < 20; k++) {
            printf("%5.3f ", warp_tab[k].wt[i]);
        }
        printf("\n");
    }
    printf("!====\n");
    for (k = 5; k < 15; k++) {
        w = 0;
        for (i = 0; i < 6; i++) {
            w += warp_tab[k].wt[i];
        }
        printf("%d %f\n", k, w);
    }
}

- (void)chkWarpTab
{
    int     i, k, ix;
    int     x;
    int     dim = [[src loopAtIndex:loop_index] dataLength];
    float   w;

//    printf("chkWarpTab:1D\n");
    for (k = 0; k < warp_tab_len; k++) {
        for (i = 0; i < kern_size; i++) {
            ix = warp_tab[k].leftIx + i*skip;
            x = ix / skip;
            w = warp_tab[k].wt[i];
            if (w > -1.0 && ((x < 0) || (x >= dim))) {
                printf("# warptab 1D ix error: k/x = %d (%d) %e\n", k, x, w);
            }
            if (w > 1.0) {
                printf("# warptab 1D weight error:tab[%d].wt[%d] = %e\n", k, i, w);

            }
            if (w != w) {
                printf("# warptab_1D weight is NaN:tab[%d].wt[%d]\n", k, i);

            }
        }
    }
}

@end

// ==== 3-D ======
// OP version not implemented yet ###
@implementation RecResampler3d

+ (id)resamplerWithSrc:(RecImage *)src dst:(RecImage *)dst map:(RecImage *)map
{
    return [[RecResampler3d alloc] initWithSrc:src dst:dst map:map];
}

- (id)initWithSrc:(RecImage *)srcImg dst:(RecImage *)dstImg map:(RecImage *)mapImg
{
    self = [super init];
    if (!self) return nil;

    mode = REC_OP; //REC_REF;   // 0:ref 1:op 2:cl, 3:cl2 default is OP
	// ### OP not implemented yet
    src = srcImg;
    dst = dstImg;
    map = mapImg;

    return self;
}

- (void)setMode:(int)warp_mode
{
    mode = warp_mode;
}

// create warp tab and resample
- (void)resample
{
    kernel = Rec_lanczos_kern(KERN_LEN, LANCZ_ORDER);
    [dst clear];
    switch (mode) {
    case REC_REF: // ref
        [self resample_ref];
        break;
    case REC_OP: // op
        [self resample_op];
        break;
    }
    free(kernel);
}

- (void)resample_op
{
    int                 i, n = [dst zDim];
	NSOperation			*op;
	NSOperationQueue	*queue = [[NSOperationQueue alloc] init];;

printf("3d resampler (op)\n");
	for (i = 0; i < n; i++) {
		op = [RecResampler3dOp opWithResampler:self slice:i];
		[queue addOperation:op];
	}
    [queue waitUntilAllOperationsAreFinished];
}

- (void)resample_ref
{
    int     i, n = [dst zDim];

    // resample
    for (i = 0; i < n; i++) {
        [self resampleSliceAt:i];
    }
}

- (void)resampleX:(int)j y:(int)i z:(int)k plane:(int)m position:(RecVector)pos
{
    int     ii, jj, kk, ix;
    float   x, y, z;
    int     xi, yi, zi;
    int     xpos, ypos, zpos;
    float   dist, wx, wy, wz, w;
    int     dim = LANCZ_ORDER * 2;
    int     xDim = [dst xDim];
    int     yDim = [dst yDim];
    int     zDim = [dst zDim];
    int     cornerIx, kernIx;
    float   *dstp, *srcp;
    int     kern_len = KERN_LEN;
	int     kern_step = kern_len / LANCZ_ORDER;

    x = pos.x * xDim + xDim/2;
    y = pos.y * yDim + yDim/2;
    z = pos.z * zDim + zDim/2;
    xi = (int)ceil(x) - LANCZ_ORDER;
    yi = (int)ceil(y) - LANCZ_ORDER;
    zi = (int)ceil(z) - LANCZ_ORDER;
    x = xi - x;
    y = yi - y;
    z = zi - z;
    cornerIx = (zi * yDim + yi) * xDim + xi;
    dstp = [dst data] + [dst dataLength] * m + (k * yDim + i) * xDim + j;
    srcp = [src data];
    for (kk = 0; kk < dim; kk++) {
        zpos = zi + kk;
        if (zpos < 0 || zpos >= zDim) {
            wz = 0;
        } else {
            dist = z + kk;
            kernIx = warp_kernel_index(dist, kern_step, kern_len);
            wz = kernel[kernIx];
            if (wz != wz) {
                printf("=== 2D, wy = NaN, kern[%d] = %f\n", kernIx, wz);
            }
        }
        for (ii = 0; ii < dim; ii++) {
            ypos = yi + ii;
            if (ypos < 0 || ypos >= yDim) {
                wy = 0;
            } else {
                dist = y + ii;
                kernIx = warp_kernel_index(dist, kern_step, kern_len);
                wy = kernel[kernIx];
                if (wy != wy) {
                    printf("=== 2D, wy = NaN, kern[%d] = %f\n", kernIx, wy);
                }
            }
            for (jj = 0; jj < dim; jj++) {
                xpos = xi + jj;
                if (xpos < 0 || xpos >= xDim) {
                    wx = 0;
                } else {
                    dist = x + jj;
                    kernIx = warp_kernel_index(dist, kern_step, kern_len);
                    wx = kernel[kernIx];
                    if (wx != wx) {
                        printf("=== 2D, wy = NaN, kern[%d] = %f\n", kernIx, wx);
                    }
                }
                w = wx * wy * wz;
                ix = cornerIx + (kk * yDim + ii) * xDim + jj;
                if (w != 0) {
                    *dstp += srcp[ix] * w;
                }
            }
        }
    }
}

// unit for single proc (warp_tab_len)
// single xy plane ?
- (void)resampleSliceAt:(int)k
{
    int         plane, pixSize = [dst pixSize];
    int         len = [map dataLength];
    int         i, j;
    int         yDim = [dst yDim];
    int         xDim = [dst xDim];
    float       *px, *py, *pz;
    RecVector   v;

    for (plane = 0; plane < pixSize; plane++) {
        for (i = 0; i < yDim; i++) {
            for (j = 0; j < xDim; j++) {
            // resample j, i, k
                px = [map data] + (k * yDim + i) * xDim + j;
                py = px + len;
                pz = py + len;
                v.x = *px;
                v.y = *py;
                v.z = *pz;
                [self resampleX:j y:i z:k plane:plane position:v];
            }
        }
    }
}

@end

// =========== resampler2d ==================
@implementation RecResamplerOp

+ (id)opWithResampler:(RecResampler *)resampler src:(float *)sp dst:(float *)dp
{
    return [[RecResamplerOp alloc] initWithResampler:resampler src:sp dst:dp];
}

- (id)initWithResampler:(RecResampler *)res src:(float *)srcP dst:(float *)dstP
{
    self = [super init];
    if (!self) return nil;

    sp = srcP;
    dp = dstP;
    resampler = res;

    return self;
}

- (void)main
{
    [resampler resampleSrc:sp dst:dp];
}

@end

// =========== resampler1d ==================
@implementation RecResampler1dOp

+ (id)opWithResampler:(RecResampler1d *)resampler src:(float *)sp dst:(float *)dp
{
    return [[RecResampler1dOp alloc] initWithResampler:resampler src:sp dst:dp];
}

- (id)initWithResampler:(RecResampler1d *)res src:(float *)srcP dst:(float *)dstP
{
    self = [super init];
    if (!self) return nil;

    sp = srcP;
    dp = dstP;
    resampler = res;

    return self;
}

- (void)main
{
    [resampler resampleSrc:sp dst:dp];
}

@end

// =========== resampler3d ==================
@implementation RecResampler3dOp

+ (id)opWithResampler:(RecResampler3d *)resampler slice:(int)sl
{
    return [[RecResampler3dOp alloc] initWithResampler:resampler slice:sl];
}

- (id)initWithResampler:(RecResampler3d *)res slice:(int)sl
{
    self = [super init];
    if (!self) return nil;

    slice = sl;
    resampler = res;

    return self;
}

- (void)main
{
    [resampler resampleSliceAt:slice];
}

@end


